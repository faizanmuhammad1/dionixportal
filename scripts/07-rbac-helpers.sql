-- RBAC helpers, claims, and signup trigger (idempotent)

-- 1) Ensure profiles.role allows all app roles
do $$ begin
  if exists (
    select 1 from information_schema.columns
    where table_schema='public' and table_name='profiles' and column_name='role'
  ) then
    begin
      alter table public.profiles drop constraint if exists profiles_role_check;
      alter table public.profiles add constraint profiles_role_check check (role in ('admin','manager','employee','client'));
    exception when others then null;
    end;
  end if;
end $$;

-- 2) Enums for claims-based RBAC
do $$ begin
  if not exists (select 1 from pg_type where typname = 'app_permission') then
    create type public.app_permission as enum (
      'projects.manage','projects.delete','tasks.delete','attachments.write','comments.delete'
    );
  end if;
  if not exists (select 1 from pg_type where typname = 'app_role') then
    create type public.app_role as enum ('admin','manager','employee','client');
  end if;
end $$;

-- 3) Tables for user roles and role permissions
create table if not exists public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  role public.app_role not null,
  unique (user_id, role)
);

create table if not exists public.role_permissions (
  id bigint generated by default as identity primary key,
  role public.app_role not null,
  permission public.app_permission not null,
  unique (role, permission)
);

insert into public.role_permissions (role, permission)
values
  ('admin','projects.manage'),
  ('admin','projects.delete'),
  ('admin','tasks.delete'),
  ('admin','attachments.write'),
  ('admin','comments.delete'),
  ('manager','projects.manage'),
  ('manager','tasks.delete'),
  ('manager','attachments.write'),
  ('manager','comments.delete')
on conflict do nothing;

-- 4) Helper: derive role from profile; helpers to check access
create or replace function public.current_role()
returns text
language sql stable security definer
set search_path = public
as $$
  select coalesce((select role from public.profiles where id = auth.uid()), 'employee');
$$;

create or replace function public.is_admin()
returns boolean
language sql stable security definer
set search_path = public
as $$
  select public.current_role() = 'admin';
$$;

create or replace function public.has_project_access(pid uuid)
returns boolean
language sql stable security definer
set search_path = public
as $$
  select exists (
      select 1 from public.projects p
      where p.id = pid and (auth.uid() = p.created_by or auth.uid() = p.manager_id)
    )
    or exists (
      select 1 from public.project_members m where m.project_id = pid and m.user_id = auth.uid()
    );
$$;

-- 5) Claims: custom access token hook and authorize()
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    select role
    into user_role
    from public.user_roles
    where user_id = (event->>'user_id')::uuid
    order by case role when 'admin' then 4 when 'manager' then 3 when 'employee' then 2 else 1 end desc
    limit 1;

    claims := coalesce(event->'claims', '{}'::jsonb);
    if user_role is not null then
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', '"employee"'::jsonb, true);
    end if;
    event := jsonb_set(event, '{claims}', claims, true);
    return event;
  end;
$$;

grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook(jsonb) to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook(jsonb) from authenticated, anon, public;

grant all on table public.user_roles to supabase_auth_admin;
revoke all on table public.user_roles from authenticated, anon, public;

do $$ begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='user_roles' and policyname='Allow auth admin to read user roles'
  ) then
    create policy "Allow auth admin to read user roles" on public.user_roles
    as permissive for select to supabase_auth_admin using (true);
  end if;
end $$;

create or replace function public.authorize(requested_permission public.app_permission)
returns boolean
language plpgsql stable security definer
set search_path = ''
as $$
declare
  has_perm int;
  jwt_role public.app_role;
begin
  select (auth.jwt() ->> 'user_role')::public.app_role into jwt_role;
  if jwt_role is null then
    return false;
  end if;
  select count(*) into has_perm
  from public.role_permissions rp
  where rp.permission = requested_permission
    and rp.role = jwt_role;
  return has_perm > 0;
end;
$$;

-- 6) Policies using claims (safe create)
do $$ begin
  if not exists (select 1 from pg_policies where tablename='projects' and policyname='projects_manage_claims') then
    create policy projects_manage_claims on public.projects for all to authenticated using ((select public.authorize('projects.manage')))
      with check ((select public.authorize('projects.manage')));
  end if;
  if not exists (select 1 from pg_policies where tablename='projects' and policyname='projects_delete_claims') then
    create policy projects_delete_claims on public.projects for delete to authenticated using ((select public.authorize('projects.delete')));
  end if;
  if not exists (select 1 from pg_policies where tablename='tasks' and policyname='tasks_delete_claims') then
    create policy tasks_delete_claims on public.tasks for delete to authenticated using ((select public.authorize('tasks.delete')));
  end if;
  if not exists (select 1 from pg_policies where tablename='attachments' and policyname='attachments_write_claims') then
    create policy attachments_write_claims on public.attachments for all to authenticated using ((select public.authorize('attachments.write')))
      with check ((select public.authorize('attachments.write')));
  end if;
  if not exists (select 1 from pg_policies where tablename='comments' and policyname='comments_delete_claims') then
    create policy comments_delete_claims on public.comments for delete to authenticated using ((select public.authorize('comments.delete')));
  end if;
end $$;

-- 7) Signup trigger: auto-create profile with default role
create or replace function public.handle_new_auth_user()
returns trigger
language plpgsql security definer
as $$
begin
  insert into public.profiles (id, role, first_name, last_name)
  values (new.id, 'employee', null, null)
  on conflict (id) do nothing;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute function public.handle_new_auth_user();

-- 8) Helper: set user role by email (updates profile + user_roles)
create or replace function public.set_user_role_by_email(p_email text, p_role public.app_role)
returns void
language plpgsql security definer
as $$
declare
  v_user_id uuid;
begin
  select id into v_user_id from auth.users where email = p_email;
  if v_user_id is null then
    raise exception 'User with email % not found', p_email;
  end if;

  insert into public.user_roles(user_id, role)
  values (v_user_id, p_role)
  on conflict (user_id, role) do nothing;

  update public.profiles set role = p_role where id = v_user_id;
end;
$$;


